![](db-modeling-3.png)

# 課題1
- ドキュメントは最新の内容をDocumentで管理、過去の変更はDocumentHistoryで管理する
- 変更ごとにDocumentHistoryにレコード追加するためデータ量が増える点が懸念点。恐らく変更点のみ差分保存すれば良いと思うがそのメカニズムが分からない
- ディレクトリは閉包テーブルを使って親子関係を管理する（下記参照）

## 8/24更新
- メンターセッションで閉包テーブルという設計方法を知ったので、これを利用するよう修正
- 閉包テーブルとはツリー構造(ファイルディレクトリとか)のデータを表現する方法の一つ。親のidを持たせて自身のテーブルを参照する方法より良い点がある。
- 今回はレコードの削除追加というユースケースが想定されるので、その扱いが楽というメリットがあるため閉包テーブルを利用
- 以下本当に簡単にメモ
### ツリー構造を表現する方法１　親のidを持たせる
例えばDirectoryテーブルでparent_idというカラムを用意し、親のディレクトリのidを格納することで階層を表すことができる。  
その場合、あるディレクトリの子供のディレクトリを探すSQLは以下の通り。（シンプルにするためにディレクトリ名だけ取得）  
select 2.name from Directory 1 join Directory 2 on 1.id = 2.parent_id where 1.id = '100';  
### 問題1 深い階層まで取得しようとすると結合がその分増える
もし子孫まで取得する場合こうなる  
select 2.name, 3.name from Directory 1 join Directory 2 on 1.id = 2.parent_id join Directory 3 on 2.id = 3.parent_id where 1.id = '100';  
このように階層が深くなるごとに結合が増えることが問題。  
### 問題2 削除が手間
https://www.ritolab.com/entry/235  
この記事に書いてあるとおり、ディレクトリの途中だけ削除するような場合、削除時にそのディレクトリの子供のparent_idを更新しないといけない。かつparent_idの制約を付けている場合順番に削除する必要がある。  
もしそのディレクトリの子孫すべてを削除するのなら問題ない。
### ツリー構造を表現する方法２　閉包テーブルを使う
アイデアとしてはDirectoryテーブルには単純にディレクトリ分のレコードをもたせ、親子の関係性は別テーブルで管理する。  
別テーブルではparent_id child_idというカラムを持ち、Directoryテーブルのツリー構造をすべて記録する。  
テーブルの内容は記事を参照  
https://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html#:~:text=A%20closure%20table%20is%20simply,to%20each%20row's%20parent%20directory  
もし子孫まで取得する場合こうなる    
select D.name from Directory D join DirectoryClosure DC on D.id = DC.child_id where DC.parent_id = '100';  
DirectoryClosureが先ほどの別テーブル、クロージャーテーブルと呼ばれるもの。この２つのテーブルのみ結合すればで済む。  
これは検索のディレクトリがどれだけ深くなってもこれ以上結合が増えないので、親のidを持たせる方法の結合が多くなる問題は解決できる。  
レコード削除の問題も、クロージャーテーブルにすべての関係が記録されているので、例えば子を削除したとしても、孫に対するレコード更新は必要だが制約が無いので削除しやすい



# 課題2
- ドキュメントのソート順をDirectoryで保存し、データ取得時はまずその値を参照し、クエリのソート順だけ動的に変更して取得する
- ソート順はSortOrderがマスタテーブルで、Directoryが外部キーsort_order_idを持つ
- ソート順の保持は他にいい方法があるのかもしれない