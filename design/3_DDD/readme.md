# 課題1
## エンテティ
DDDではドメインをシステムで使うためモデル化し、そのモデルをコードに落とし込む。
モデルをコードで表現するパターンは次の4つがある。
- エンテティ
- 値オブジェクト
- ドメインサービス
- ドメインイベント

この中でモデルをオブジェクト(値と振る舞いを持つモノ)として表現するのが、エンテティと値オブジェクトの2つ。
残る2つはオブジェクトとして表現するのに無理があるものを表現するのに使う。
例えば、集合に対する操作など。

エンテティとは、次の特徴を持つオブジェクト。
- 識別子が同一であれば同一
- 可変

例えば、社員エンテティは社員番号という識別子が同じなら同一であり、
名前や部署などが変更しても良い（可変）

## 値オブジェクト
値オブジェクトとは、次の特徴を持つオブジェクト。
- 保持する属性がすべて同じであれば同一
- 不変（作成されたら破棄されるのみ）

例えば、10円というお金は金額という属性が同じであればどの10円でも同じであり、
金額を書き換えて100円に変更することはできない（不変）

なぜオブジェクトを表現するのにエンテティと値オブジェクトを使い分けるのか？
プログラミングのプラクティスである「できるだけ不変に」を叶えるために値オブジェクトが存在するのでは。
実際値オブジェクトを使わずすべてエンテティで表現することは可能。

## 集約
オブジェクトのまとまりを表し、整合性を保ちながらデータを更新する単位。
例えばorderとorderdetailなど。

また、集約の中で親を成すオブジェクト（例えばorder）であるものを集約ルートと呼び、
集約ルートを使ってデータを更新する。

集約を用いることで次のようなメリットがある。
- Serviceクラスに大量のリポジトリを書くことを防ぐことができる
- オブジェクトの一部をロードした時の子要素のNULLを防ぐことができる

[「集約」でデータアクセスの 3 つの課題に立ち向かう](https://qiita.com/os1ma/items/28f5d03d3b92e6a1e1d8)

## ユビキタス言語
全員で同じ言語でコミュニケーションを行うための共通言語のこと。
開発者からドメインエキスパートまで共通言語を利用することでコミュニケーションを円滑にする。

例えば、プロダクト名、UI、機能など。

## 境界づけられたコンテキスト
モデル、言語を統一する一つの区切り。
特に大規模システムだと全体を一つのモデルにするのが難しくなるため、コンテキストに分けでその中でそれぞれの解釈のモデルを作成する。
例えば「商品」というモデルは販売者と配送者で異なる振る舞いが必要になるので、販売コンテキストと配送コンテキストに分けてそれぞれに商品モデルを作る。

## ドメイン
ドメインとは対象とする事業が取り扱う世界を表す。
例えば採用管理システムなら、採用の業界がドメインになる

## ドメインサービス
エンテティや値オブジェクトではなく、それらの外で記述した方ロジックを記載するのに、
ドメインサービスとアプリケーションサービスがある。
これらの特徴として、ステートレス（状態を持たない）がある。

ドメインサービスはドメイン層の中に含まれ、ビジネスロジックを持つことができる点が特徴。
ドメインサービスの実装には主に次のような二様がある。
- エンテティ、値オブジェクト、集約を利用して計算するビジネスルール
- クライアント側が複雑にならないようにドメインオブジェクトの変換、まとめ

## リポジトリ
オブジェクトの保管、取り出しを行うコンポーネント。
その先にはデータベースがあるが、隠蔽されていて利用する側はデータベースを意識する必要がない。

リポジトリは集約の単位でオブジェクトを出し入れするので、
集約ルートとリポジトリはペアで存在する。

## アプリケーション（ユースケース層と呼ばれることも）
アプリケーションサービスとは、アプリケーション層に存在するドメインモデルのクライアント。
アプリケーションサービスの役割はタスクの調整などであり、薄い処理を行うレイヤーである。（ドメインサービスとは対照的）

基本的なアーキテクチャの方針としてUI層がアプリケーション層のアプリケーションサービスを使用し、ドメインモデルを呼び出す。	

## CQS/CQRS（似ているため、違いを重点的に調べてみましょう）
CQS(Command/Query Separation)は、メソッドを次の二つのどちらかに設計すること。
- メソッドがオブジェクトの状態を変更する・・コマンドと呼ばれる
- メソッドがある値を返却する・・クエリと呼ばれる

これらを分けることで、保守性や再利用性を高めることができる。

CQRS(Command Query Responsibility Segregation)は、CQSを落とし込んだアーキテクチャパターン。
コマンド処理とクエリ処理を切り離すことにより保守性や再利用性を高めることができるとともに、
いくつかのメリットを享受できる。
- データストアに対するロック競合を減らせる
- 更新処理のパフォーマンスを上げることができる

[ソフトウェアの設計原則②コマンド・クエリ分離の原則（CQS）](https://rakusui.org/cqs/)

## DTO
DTO(Data Transfer Object)はデータだけを持つオブジェクト。
まとまったデータを転送するために使われる。
振る舞いはなく、ゲッターやセッターなど最低限の関数しか実装されていない。

## ドメインモデル貧血症
データとそのゲッター/セッターしか持たないドメインのこと。
本来ドメイン層（ドメイン、ドメインサービス）には業務ロジックを書くべきだが、それがないため貧血症と比喩されている。

ドメインモデル貧血症になると、ドメインを使う側でロジックが書かれるので、責務が分散してしまう。

# 課題2
## 境界付けられたコンテキストの例
受注を管理するシステムで「商品」という概念を販売部門と配送部門が扱う際、
同じ「商品」だとしても必要なプロパティが異なる。
- 販売部門・・商品コード、商品名、価格、品質情報などが必要
- 配送部門・・商品コード、商品サイズ、配送時の情報（例：割れ物注意）などが必要

## Humanエンテティ
```TypeScript
class Human {
	id: String;
	bloodType: String;
	birthDate: Date;
	name: String;

	constructor (id: String, bloodType: String, birthDate: Date, name: String) {
		this.id = id;
		this.bloodType = bloodType;
		this.birthDate = birthDate;
		this.name= name;
	}
}
```

## 新人エンジニアのコードがいけない理由
- 各プロパティのバリデーションをすべてHumanクラスの中で行っているため、Humanクラスの役割が多くなっている

## Humanエンテティの各プロパティをオブジェクトに置き換え
```TypeScript
class Id {
    private id: string;

    constructor(id: string) {
        const reg = new RegExp(/^[0-9a-zA-Z]*$/);
        if (reg.test(id)) {
            this.id = id;
        } else {
            throw new Error("Only numbers and alphabets can be used");
        }
    }
}

type bloodType = 'a' | 'b' | 'o' | 'ab';
class BloodType {
    private bloodType: string;

    constructor(bloodType: bloodType) {
        this.bloodType = bloodType;
    }
}

class BirthDate {
    private birthDate: Date;

    constructor(birthDate: Date) {
        const timeDiff = Math.abs(Date.now() - birthDate.getTime());
        const age = Math.floor((timeDiff / (1000 * 3600 * 24)) / 365.25);
        if (age >= 20) {
            this.birthDate = birthDate;
        } else {
            throw new Error('Age must be over 20');
        }   
    }
}

class Name {
    private name: string;
    
    constructor(name: string) {
        if (name.length < 20) {
            this.name = name;
        } else {
            throw new Error('Name must be shorter than 20 letters');
        }
    }
}
```

# 課題3
ドメイン知識が漏れているとは、ドメインモデルに書かれるべきドメインロジックがアプリケーションサービス層に散在している（ドメインモデルから漏れている）という状態を指す。

[ドメイン知識が漏れるとは何なのか](https://zenn.dev/praha/articles/92c6494570a4dc)
```TypeScript
class Account {
    public id: string;
    public subscriptionType: string;

    constructor(id: string, subscriptionType: string) {
        this.id = id;
        this.subscriptionType = subscriptionType;
    }
}

class Usecase1 {
    method(item: Account) {
        if (item.subscriptionType === 'Standard') {
            // Standard会員には広告を表示する
        }
    }
}
```

# 課題4
- Q1: DDDのメリットはなんでしょうか？
- Q2: DDDのデメリットはなんでしょうか？
- Q3: ファクトリとはなんでしょうか？